import { useState, useCallback, useRef, useEffect } from 'react';
import AIServiceManager from '../../service/ai/AIServiceManager.js';

/**
 * Hook personalizado para manejo de feedback de IA
 * Sigue el patr√≥n establecido de Ventilab
 */
export const useAIFeedback = (config = {}) => {
  // Configuraci√≥n por defecto
  const defaultConfig = {
    maxHistorySize: 10,
    enableMetrics: true,
    autoAnalyze: false,
    criticalErrorThreshold: 0.7,
    learningMetrics: {
      trackImprovements: true,
      trackErrors: true,
      trackConfidence: true
    }
  };

  const finalConfig = { ...defaultConfig, ...config };

  // Estados principales
  const [feedback, setFeedback] = useState(null);
  const [recommendations, setRecommendations] = useState([]);
  const [analysisHistory, setAnalysisHistory] = useState([]);
  const [error, setError] = useState(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);

  // Estados adicionales
  const [currentAIModel, setCurrentAIModel] = useState('gemini');
  const [learningMetrics, setLearningMetrics] = useState({
    totalAnalyses: 0,
    successfulAnalyses: 0,
    averageConfidence: 0,
    improvementTrend: 0,
    criticalErrorsFixed: 0,
    lastAnalysisTime: null
  });

  // Referencias para evitar re-renders innecesarios
  const analysisCountRef = useRef(0);
  const lastAnalysisRef = useRef(null);

  /**
   * Analizar configuraci√≥n de ventilador
   */
  const analyzeConfiguration = useCallback(async (userConfig, optimalConfig, ventilationMode, patientData = null) => {
    if (isAnalyzing) {
      console.warn('An√°lisis ya en progreso, ignorando solicitud');
      return;
    }

    setIsAnalyzing(true);
    setError(null);
    analysisCountRef.current++;

    try {
      console.log(`üîç Iniciando an√°lisis #${analysisCountRef.current}...`);
      
      const result = await AIServiceManager.analyzeVentilatorConfiguration(
        userConfig,
        optimalConfig,
        ventilationMode,
        patientData
      );

      if (result.success) {
        // Actualizar feedback principal
        setFeedback({
          analysis: result.analysis,
          confidence: result.confidence || 0.8,
          provider: result.provider || 'unknown',
          fallbackUsed: result.fallbackUsed || false,
          responseTime: result.responseTime || 0,
          timestamp: new Date().toISOString()
        });

        // Extraer recomendaciones
        const extractedRecommendations = extractRecommendations(result.analysis);
        setRecommendations(extractedRecommendations);

        // Actualizar historial
        const newAnalysis = {
          id: Date.now(),
          timestamp: new Date().toISOString(),
          userConfig,
          optimalConfig,
          ventilationMode,
          patientData,
          result: {
            analysis: result.analysis,
            confidence: result.confidence,
            provider: result.provider,
            fallbackUsed: result.fallbackUsed,
            responseTime: result.responseTime
          },
          recommendations: extractedRecommendations
        };

        setAnalysisHistory(prev => {
          const newHistory = [newAnalysis, ...prev];
          return newHistory.slice(0, finalConfig.maxHistorySize);
        });

        // Actualizar m√©tricas de aprendizaje
        if (finalConfig.enableMetrics) {
          updateLearningMetrics(result, true);
        }

        console.log('‚úÖ An√°lisis completado exitosamente');
        return result;

      } else {
        throw new Error(result.error || 'Error desconocido en el an√°lisis');
      }

    } catch (err) {
      console.error('‚ùå Error en an√°lisis:', err);
      setError(err.message || 'Error al analizar la configuraci√≥n');
      
      // Actualizar m√©tricas de error
      if (finalConfig.enableMetrics) {
        updateLearningMetrics(null, false, err);
      }

      return {
        success: false,
        error: err.message,
        analysis: 'No se pudo completar el an√°lisis en este momento.'
      };
    } finally {
      setIsAnalyzing(false);
    }
  }, [isAnalyzing, finalConfig.maxHistorySize, finalConfig.enableMetrics]);

  /**
   * Analizar errores cr√≠ticos espec√≠ficos
   */
  const analyzeCriticalErrors = useCallback(async (userConfig, ventilationMode, patientData = null) => {
    if (isAnalyzing) {
      console.warn('An√°lisis ya en progreso, ignorando solicitud');
      return;
    }

    setIsAnalyzing(true);
    setError(null);

    try {
      console.log('üö® Analizando errores cr√≠ticos...');
      
      // Prompt espec√≠fico para errores cr√≠ticos
      const criticalPrompt = `Eres un experto en ventilaci√≥n mec√°nica. Analiza SOLO los errores CR√çTICOS en esta configuraci√≥n que podr√≠an poner en peligro al paciente.

CONFIGURACI√ìN:
${formatConfigForPrompt(userConfig)}

MODO: ${ventilationMode === 'volume' ? 'Volumen Control' : 'Presi√≥n Control'}

${patientData ? `DATOS DEL PACIENTE:
- Edad: ${patientData.patientBasicData?.edad || 'No especificada'} a√±os
- Peso: ${patientData.patientBasicData?.peso || 'No especificado'} kg
- Diagn√≥stico: ${patientData.patientBasicData?.diagnostico || 'No especificado'}` : ''}

INSTRUCCIONES:
1. Identifica √öNICAMENTE errores CR√çTICOS (riesgo de vida)
2. Prioriza por severidad m√°xima
3. Proporciona acciones inmediatas
4. Enf√≥cate en seguridad del paciente

FORMATO:
- ERROR CR√çTICO: [descripci√≥n]
- ACCI√ìN INMEDIATA: [qu√© hacer ahora]
- JUSTIFICACI√ìN: [por qu√© es cr√≠tico]

Responde en espa√±ol.`;

      const result = await AIServiceManager.generateResponse(criticalPrompt, {
        temperature: 0.3,
        maxTokens: 800
      });

      if (result.success) {
        const criticalAnalysis = {
          analysis: result.response,
          confidence: result.confidence,
          provider: result.provider,
          fallbackUsed: result.fallbackUsed,
          responseTime: result.responseTime,
          timestamp: new Date().toISOString(),
          type: 'critical_errors'
        };

        setFeedback(criticalAnalysis);
        
        // Extraer acciones cr√≠ticas
        const criticalActions = extractCriticalActions(result.response);
        setRecommendations(criticalActions);

        // Actualizar historial
        const newAnalysis = {
          id: Date.now(),
          timestamp: new Date().toISOString(),
          userConfig,
          ventilationMode,
          patientData,
          result: criticalAnalysis,
          recommendations: criticalActions,
          type: 'critical_analysis'
        };

        setAnalysisHistory(prev => {
          const newHistory = [newAnalysis, ...prev];
          return newHistory.slice(0, finalConfig.maxHistorySize);
        });

        // Actualizar m√©tricas
        if (finalConfig.enableMetrics) {
          updateLearningMetrics(result, true);
        }

        console.log('‚úÖ An√°lisis de errores cr√≠ticos completado');
        return result;

      } else {
        throw new Error(result.error || 'Error en an√°lisis de errores cr√≠ticos');
      }

    } catch (err) {
      console.error('‚ùå Error en an√°lisis cr√≠tico:', err);
      setError(err.message || 'Error al analizar errores cr√≠ticos');
      
      if (finalConfig.enableMetrics) {
        updateLearningMetrics(null, false, err);
      }

      return {
        success: false,
        error: err.message,
        analysis: 'No se pudo completar el an√°lisis de errores cr√≠ticos.'
      };
    } finally {
      setIsAnalyzing(false);
    }
  }, [isAnalyzing, finalConfig.maxHistorySize, finalConfig.enableMetrics]);

  /**
   * Limpiar feedback actual
   */
  const clearFeedback = useCallback(() => {
    setFeedback(null);
    setRecommendations([]);
    setError(null);
    console.log('üßπ Feedback limpiado');
  }, []);

  /**
   * Obtener m√©tricas de aprendizaje
   */
  const getMetrics = useCallback(() => {
    const aiStats = AIServiceManager.getProviderStats();
    
    return {
      // M√©tricas del hook
      learning: learningMetrics,
      
      // M√©tricas del AI Service Manager
      ai: {
        currentProvider: aiStats.currentProvider,
        availableProviders: aiStats.availableProviders,
        globalStats: aiStats.globalStats,
        providerStats: aiStats.providerStats
      },
      
      // M√©tricas espec√≠ficas del usuario
      user: {
        totalAnalyses: analysisCountRef.current,
        analysisHistory: analysisHistory.length,
        lastAnalysis: lastAnalysisRef.current,
        improvementTrend: learningMetrics.improvementTrend,
        criticalErrorsFixed: learningMetrics.criticalErrorsFixed
      }
    };
  }, [learningMetrics, analysisHistory]);

  /**
   * Cambiar modelo de IA
   */
  const changeAIModel = useCallback(async (newModel) => {
    try {
      console.log(`üîÑ Cambiando modelo de IA a: ${newModel}`);
      
      const result = AIServiceManager.switchModel(newModel);
      
      if (result.success) {
        setCurrentAIModel(newModel);
        console.log(`‚úÖ Modelo cambiado a: ${newModel}`);
        return {
          success: true,
          model: newModel,
          message: result.message
        };
      } else {
        throw new Error(result.error || 'Error al cambiar modelo');
      }
    } catch (err) {
      console.error('‚ùå Error cambiando modelo:', err);
      setError(err.message);
      return {
        success: false,
        error: err.message,
        availableModels: result?.availableProviders || []
      };
    }
  }, []);

  /**
   * Extraer recomendaciones del an√°lisis
   */
  const extractRecommendations = (analysis) => {
    if (!analysis || typeof analysis !== 'string') return [];
    
    const recommendations = [];
    const lines = analysis.split('\n');
    
    lines.forEach(line => {
      const trimmed = line.trim();
      if (trimmed.includes('recomendaci√≥n') || 
          trimmed.includes('sugerencia') || 
          trimmed.includes('deber√≠a') ||
          trimmed.includes('considera')) {
        recommendations.push(trimmed);
      }
    });
    
    return recommendations.slice(0, 5); // M√°ximo 5 recomendaciones
  };

  /**
   * Extraer acciones cr√≠ticas
   */
  const extractCriticalActions = (analysis) => {
    if (!analysis || typeof analysis !== 'string') return [];
    
    const actions = [];
    const lines = analysis.split('\n');
    
    lines.forEach(line => {
      const trimmed = line.trim();
      if (trimmed.includes('ACCI√ìN INMEDIATA') || 
          trimmed.includes('ERROR CR√çTICO') ||
          trimmed.includes('URGENTE')) {
        actions.push(trimmed);
      }
    });
    
    return actions;
  };

  /**
   * Formatear configuraci√≥n para prompt
   */
  const formatConfigForPrompt = (config) => {
    if (!config || typeof config !== 'object') return 'Configuraci√≥n no disponible';
    
    return Object.entries(config)
      .filter(([key, value]) => value !== undefined && value !== null && value !== '')
      .map(([key, value]) => `- ${formatParameterName(key)}: ${value} ${getUnit(key)}`)
      .join('\n');
  };

  /**
   * Formatear nombre de par√°metro
   */
  const formatParameterName = (key) => {
    const names = {
      fio2: 'FiO2',
      volumen: 'Volumen Tidal',
      presionMax: 'Presi√≥n M√°xima',
      peep: 'PEEP',
      frecuencia: 'Frecuencia Respiratoria',
      inspiracionEspiracion: 'Relaci√≥n I:E',
      pausaInspiratoria: 'Pausa Inspiratoria',
      pausaEspiratoria: 'Pausa Espiratoria',
      qMax: 'Flujo M√°ximo'
    };
    return names[key] || key;
  };

  /**
   * Obtener unidad de par√°metro
   */
  const getUnit = (key) => {
    const units = {
      fio2: '%',
      volumen: 'ml',
      presionMax: 'cmH2O',
      peep: 'cmH2O',
      frecuencia: 'resp/min',
      inspiracionEspiracion: '',
      pausaInspiratoria: 's',
      pausaEspiratoria: 's',
      qMax: 'L/min'
    };
    return units[key] || '';
  };

  /**
   * Actualizar m√©tricas de aprendizaje
   */
  const updateLearningMetrics = (result, success, error = null) => {
    if (!finalConfig.enableMetrics) return;

    setLearningMetrics(prev => {
      const newMetrics = { ...prev };
      
      newMetrics.totalAnalyses++;
      newMetrics.lastAnalysisTime = new Date().toISOString();
      
      if (success && result) {
        newMetrics.successfulAnalyses++;
        
        // Actualizar confianza promedio
        if (result.confidence) {
          const totalConfidence = (prev.averageConfidence * (newMetrics.successfulAnalyses - 1)) + result.confidence;
          newMetrics.averageConfidence = totalConfidence / newMetrics.successfulAnalyses;
        }
        
        // Detectar mejoras (confianza creciente)
        if (result.confidence > prev.averageConfidence) {
          newMetrics.improvementTrend++;
        }
        
        // Detectar errores cr√≠ticos corregidos
        if (result.analysis && result.analysis.includes('cr√≠tico')) {
          newMetrics.criticalErrorsFixed++;
        }
      }
      
      return newMetrics;
    });
  };

  /**
   * Efecto para inicializaci√≥n
   */
  useEffect(() => {
    console.log('üéØ useAIFeedback inicializado');
    
    // Verificar disponibilidad del AI Service Manager
    const isAvailable = AIServiceManager.isProviderAvailable('gemini');
    if (!isAvailable) {
      console.warn('‚ö†Ô∏è AI Service Manager no disponible');
    }
    
    return () => {
      console.log('üßπ useAIFeedback cleanup');
    };
  }, []);

  // Retornar interfaz del hook
  return {
    // Data
    feedback,
    recommendations,
    analysisHistory,
    error,
    
    // Loading states
    isAnalyzing,
    
    // Primary actions
    analyzeConfiguration,
    analyzeCriticalErrors,
    
    // Secondary actions
    clearFeedback,
    getMetrics,
    changeAIModel,
    
    // Additional data
    currentAIModel,
    learningMetrics,
    
    // Utility functions
    isAvailable: AIServiceManager.isProviderAvailable(currentAIModel),
    availableModels: AIServiceManager.getAvailableProviders()
  };
};

export default useAIFeedback;
